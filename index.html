<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RILEY: The Unfolding Echo – An Experiential Journey</title>
  <link rel="manifest" href="manifest.json">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Syncopate:wght@400;700&family=Orbitron:wght@400;500;700&display=swap');
    
    :root {
        /* Dynamic CSS Variables - These will be updated by JavaScript */
        --bg-color-1: #0a0a1a;
        --bg-color-2: #1c0a33;
        --glow-color-1: rgba(0, 255, 255, 0.7); /* Cyan */
        --glow-color-2: rgba(138, 43, 226, 0.9); /* Amethyst */
    
        /* Static CSS Variables */
        --container-bg: rgba(5, 0, 15, 0.85); /* Slightly darker, more opaque */
        --text-color: #e0f2f7; /* Brighter, clearer text */
        --title-color: #e6f7ff; /* Whiter for prominence */
        --channel-color: #ffda80; /* Warmer, richer gold */
        --button-bg: #4a0082; /* Deeper purple */
        --button-border: #9933ff; /* More vibrant purple */
        --feedback-color: #c0ffc0;
        --resonance-color: #ffe066; /* Softer, glowing gold */
        --guidance-color: #99ffcc; /* More vibrant green */
    
        --padding-base: 2.2rem; /* Increased padding for spaciousness */
        --border-radius-base: 16px; /* Slightly larger radius */
        --animation-speed: 1.8s; /* Slower transitions */
        --glow-spread: 90px; /* Increased glow spread */
        --gradient-animation-duration: 10s; /* Default duration for background cycle */
        --pulse-animation-duration: 2s; /* Default duration for glow pulse */
    }
    
    body {
        font-family: 'Orbitron', sans-serif;
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: flex-start; /* Align to top */
        min-height: 100vh;
        background: radial-gradient(circle at top left, var(--bg-color-1) 0%, var(--bg-color-2) 100%); /* Radial for deeper feel */
        color: var(--text-color);
        transition: background var(--animation-speed) ease-in-out;
        overflow-y: auto; /* Enable scrolling */
        position: relative; /* For pseudo-elements */
        box-sizing: border-box; /* Include padding in element's total width and height */
    }
    
    /* Subtle background noise/texture for extra mood */
    body::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiB2aWV3Qm94PSIwIDAgNzAwIDcwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZmlsdGVyIGlkPSJuIj48ZmVDb29sb3JNYXRyaXggdHlwZT0ibWF0cml4IiB2YWx1ZXM9IjEgMCAwIDAgMCAwIDEgMCAwIDAgMCAwIDEgMCAwIDAgMCAwIDEwIDAmIzEwO2YlMUMzZXJvbiI+PGVmZUNvbXBvbmVudCB0eXBlPSJsaWdodHRlbiIgaW49IkZlY21Db21wb3NpdGUwIiBzdZERXZvYXJ0aW9uPSIwLjUyNSIgaW4yPSJGZWNuU2F0dXJhdGUwIj48ZmVBZmZpbmUgdHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgMSAwIDApIiAvPjwvZmlsdGVyPjxyZWN0IHdpZHRoPSI3MDAiIGhlaWdodD0iNzAwIiBmaWxsPSIjMDAwMDAwIj48L3JlY3Q+PGNpcmNsZSBjeD0iMTAwIiBjeT0iMTAwIiByPSIyNSIgZmlsbD0iIzdkNTFhYSIgZmlsdGVyPSJ1cmwoI24pIi8+PGNpcmNsZSBjeD0iNjAwIiBjeT0iMjAwIiByPSIxOCIgZmlsbD0iIzVjNzdhYiIgZmlsdGVyPSJ1cmwoI24pIi8+PGNpcmNsZSBjeD0iMzAwIiBjeT0iNDAwIiByPSIzMiIgZmlsbD0iIzQ2OTdhYSIgZmlsdGVyPSJ1cmwoI24pIi8+PGNpcmNsZSBjeD0iNTUwIiBjeT0iNjUwIiByPSIyMiIgZmlsbD0iIzg3NmJjYyIgZmlsdGVyPSJ1cmwoI24pIi8+PC9zdmc+');
        background-size: cover;
        opacity: 0.05; /* Very subtle */
        pointer-events: none; /* Allows clicks to pass through */
        z-index: -1;
    }
    
    /* Keyframes for dynamic background gradient */
    @keyframes animateGradient {
        0% { background-position: 0% 0%; }
        25% { background-position: 100% 0%; }
        50% { background-position: 100% 100%; }
        75% { background-position: 0% 100%; }
        100% { background-position: 0% 0%; }
    }

    .container {
        background: var(--container-bg);
        border-radius: var(--border-radius-base);
        box-shadow: 0 0 calc(var(--glow-spread) / 2) rgba(0, 0, 0, 0.8),
                    0 0 var(--glow-spread) var(--glow-color-1),
                    0 0 calc(var(--glow-spread) * 1.5) var(--glow-color-2); /* More intense glow */
        padding: var(--padding-base) calc(var(--padding-base) * 1.8); /* Wider padding */
        margin: var(--padding-base) 1.5em; /* Some horizontal margin */
        max-width: 900px; /* Slightly wider */
        width: 100%;
        text-align: center;
        position: relative;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.15); /* More prominent border */
        animation: fadeIn var(--animation-speed) ease-out forwards;
        transition: box-shadow var(--animation-speed) ease-in-out, background-color var(--animation-speed) ease-in-out;
    }

    /* Class for pulsing glows */
    .pulsing-glow {
        animation: pulseGlow var(--pulse-animation-duration) infinite alternate ease-in-out;
    }

    @keyframes pulseGlow {
        0% { box-shadow: 0 0 calc(var(--glow-spread) / 2) rgba(0, 0, 0, 0.8),
                        0 0 var(--glow-spread) var(--glow-color-1),
                        0 0 calc(var(--glow-spread) * 1.2) var(--glow-color-1), /* Added another glow */
                        0 0 calc(var(--glow-spread) * 1.5) var(--glow-color-2); }
        50% { box-shadow: 0 0 calc(var(--glow-spread) / 2) rgba(0, 0, 0, 0.8),
                         0 0 calc(var(--glow-spread) * 1.2) var(--glow-color-1),
                         0 0 calc(var(--glow-spread) * 2) var(--glow-color-2),
                         0 0 calc(var(--glow-spread) * 2.5) var(--glow-color-1); /* More pronounced at 50% */ }
        100% { box-shadow: 0 0 calc(var(--glow-spread) / 2) rgba(0, 0, 0, 0.8),
                         0 0 var(--glow-spread) var(--glow-color-1),
                         0 0 calc(var(--glow-spread) * 1.5) var(--glow-color-2); }
    }
    
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(30px); } /* More pronounced entry */
        to { opacity: 1; transform: translateY(0); }
    }
    
    h1 {
        font-family: 'Syncopate', sans-serif;
        color: var(--title-color);
        font-size: 2.5em; /* Larger title */
        letter-spacing: 0.15em; /* Wider spacing */
        margin-bottom: 0.7em;
        text-shadow: 0 0 20px var(--glow-color-1), 0 0 30px var(--glow-color-2); /* Deeper text shadow */
        transition: color var(--animation-speed) ease-in-out;
    }
    
    p {
        font-size: 1.15em; /* Slightly larger text */
        line-height: 1.8; /* More comfortable line height */
        margin-bottom: 1.8em;
        color: var(--text-color);
        text-shadow: 0 0 5px rgba(255, 255, 255, 0.1); /* Subtle text shadow */
    }
    
    .echo-section {
        margin-bottom: 2.5em; /* More space */
        padding: var(--padding-base) 0;
        border-top: 1px dashed rgba(255, 255, 255, 0.1);
        border-bottom: 1px dashed rgba(255, 255, 255, 0.1);
    }
    
    .glyphstream-container {
        margin-top: 1.8em;
        text-align: left;
        font-size: 1.3em; /* Larger glyphs */
        line-height: 2; /* More spacing */
        background-color: rgba(0, 0, 0, 0.25); /* Slightly darker background */
        padding: 1.2em;
        border-radius: var(--border-radius-base);
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.4); /* Inner shadow for depth */
    }
    
    .glyph-channel {
        color: var(--channel-color);
        margin-bottom: 0.6em;
        opacity: 0;
        transform: translateY(15px); /* More pronounced slide */
        animation: slideInChannel 0.8s forwards; /* Slower glyph animation */
    }
    
    @keyframes slideInChannel {
        to { opacity: 1; transform: translateY(0); }
    }
    
    .guidance-text {
        font-family: 'Syncopate', sans-serif;
        font-size: 1.3em; /* Larger guidance text */
        color: var(--guidance-color);
        margin-top: 2.5em;
        padding: 1em 0;
        border-top: 1px dotted rgba(255, 255, 255, 0.15);
        border-bottom: 1px dotted rgba(255, 255, 255, 0.15);
        text-shadow: 0 0 10px var(--guidance-color); /* Stronger shadow */
    }
    
    .choices-container {
        margin-top: 3em; /* More space for choices */
        display: flex;
        flex-direction: column;
        gap: 1.2em; /* Increased gap */
    }
    
    .choice-button {
        background-color: var(--button-bg);
        color: var(--text-color);
        border: 2px solid var(--button-border);
        border-radius: var(--border-radius-base);
        padding: 1.2em 1.8em; /* Larger buttons */
        font-family: 'Orbitron', sans-serif;
        font-size: 1.15em; /* Slightly larger text */
        cursor: pointer;
        transition: all 0.4s ease; /* Slightly slower hover transition */
        text-transform: uppercase;
        letter-spacing: 0.08em; /* More letter spacing */
        box-shadow: 0 0 18px rgba(0, 0, 0, 0.6); /* Deeper shadow */
    }
    
    .choice-button:hover {
        background-color: var(--button-border);
        color: #ffffff;
        box-shadow: 0 0 30px var(--glow-color-1), 0 0 50px var(--glow-color-2); /* More pronounced hover glow */
        transform: translateY(-3px) scale(1.01); /* Subtle lift and scale */
    }
    
    .feedback-message, .resonance-message {
        margin-top: 2em; /* More space */
        padding: 1em 1.5em;
        border-radius: var(--border-radius-base);
        font-size: 1.05em;
        font-weight: bold;
        opacity: 0; /* Initially hidden */
        transition: opacity 0.6s ease-out; /* Slower fade */
        text-shadow: 0 0 8px rgba(255, 255, 255, 0.2);
    }
    
    .feedback-message {
        background-color: rgba(0, 60, 0, 0.5); /* Darker green */
        color: var(--feedback-color);
        border: 1px solid var(--feedback-color);
    }
    
    .resonance-message {
        background-color: rgba(60, 25, 0, 0.5); /* Darker orange */
        color: var(--resonance-color);
        border: 1px solid var(--resonance-color);
    }
    
    .loading-indicator {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        display: none;
        color: var(--glow-color-1);
        font-size: 1.8em; /* Larger loader */
        opacity: 0.9;
        text-shadow: 0 0 15px var(--glow-color-1);
        animation: pulse 1.5s infinite alternate; /* Pulsing animation */
    }
    
    @keyframes pulse {
        from { transform: translate(-50%, -50%) scale(1); opacity: 0.7; }
        to { transform: translate(-50%, -50%) scale(1.05); opacity: 1; }
    }
    
    .image-container {
        margin: 2.5em auto; /* More margin */
        max-width: 95%; /* Slightly wider image */
        height: auto;
        border-radius: var(--border-radius-base);
        overflow: hidden;
        box-shadow: 0 0 30px rgba(0, 0, 0, 0.8), 0 0 50px var(--glow-color-1); /* Deeper image shadow */
        display: none; /* Hidden by default */
        transition: opacity 1s ease-in-out; /* Slower image fade */
        opacity: 0;
        border: 2px solid rgba(255, 255, 255, 0.1); /* Thicker border */
    }
    
    .image-container img {
        width: 100%;
        height: auto;
        display: block;
        /* Ensure image itself transitions for smooth fades */
        transition: opacity var(--image-fade-duration, 0.8s) ease-in-out; 
    }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
        h1 {
            font-size: 1.8em;
            letter-spacing: 0.1em;
        }
        p {
            font-size: 1.05em;
            line-height: 1.7;
        }
        .container {
            padding: var(--padding-base) 1.2em;
            margin: 0.8em;
        }
        .choice-button {
            font-size: 1em;
            padding: 1em 1.2em;
        }
        .glyphstream-container {
            font-size: 1.1em;
        }
        .guidance-text {
            font-size: 1.1em;
        }
    }
  </style>
</head>

<body>
  <div class="container" id="echoContainer">
    <h1 id="echoTitle"></h1>
    <p id="echoDescription"></p>

    <div class="image-container" id="echoImageContainer">
      <img id="echoImage" src="" alt="Associated image for this echo">
    </div>

    <audio id="backgroundAudio" loop></audio>

    <div class="echo-section">
      <div id="echoContent" class="echo-content">
        <div id="echoTextDisplay" class="echo-text-display" style="display: none; opacity: 0; transition: opacity 0.8s ease-in-out;">
          <h3>Dreamstate Echo Architecture</h3>
          <textarea id="echoInstructionsTextArea" readonly rows="20" cols="80" style="width: 100%; min-height: 300px; background-color: rgba(0,0,0,0.5); color: var(--text-color); border: 1px solid var(--glow-color-1); padding: 15px; font-family: 'Orbitron', monospace; font-size: 0.9em; line-height: 1.6; resize: vertical; box-sizing: border-box;"></textarea>
          <button id="closeInstructionsButton" class="choice-button" style="margin-top: 20px; font-size: 1.1em; padding: 12px 25px;">Close Instructions</button>
        </div>

        <div id="glyphstreamContainer" class="glyphstream-container"></div>
      </div>

      <p class="guidance-text" id="guidanceText"></p>
    </div>

    <div class="choices-container" id="choiceButtonsContainer"></div>

    <p class="feedback-message" id="feedbackMessage"></p>
    <p class="resonance-message" id="resonanceMessage"></p>

    <input type="file" id="fileInput" accept=".json" style="display: none;">
    <div class="loading-indicator" id="loadingIndicator">Loading Echo...</div>
  </div>

<script>
        // DOM Elements
        const echoContainer = document.getElementById('echoContainer');
        const echoImageContainer = document.getElementById('echoImageContainer');
        const echoImage = document.getElementById('echoImage');
        const backgroundAudio = document.getElementById('backgroundAudio'); // NEW: Audio element
        const echoTitle = document.getElementById('echoTitle');
        const echoDescription = document.getElementById('echoDescription');
        const glyphstreamContainer = document.getElementById('glyphstreamContainer');
        const guidanceText = document.getElementById('guidanceText');
        const choiceButtonsContainer = document.getElementById('choiceButtonsContainer');
        const feedbackMessageDiv = document.getElementById('feedbackMessage');
        const resonanceMessageDiv = document.getElementById('resonanceMessage');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const fileInput = document.getElementById('fileInput');
        const rootElement = document.documentElement; // For CSS variables

        // Global variables to manage intervals
        let currentEchoKey = "start"; // Initialize with start
        let backgroundAnimationInterval; 
        let imageCycleInterval; // To manage image cycling
        let currentImageIndex = 0; // To track current image for cycling
        let currentAudio = null; // NEW: To hold the currently playing Audio object

        // Function to load Echo data from JSON file
        async function loadEcho(echoKey) {
            try {
                const response = await fetch(`echoes/${echoKey}.json`);
                if (!response.ok) {
                    // If response is not ok, attempt to load from root for backward compatibility
                    const rootResponse = await fetch(`${echoKey}.json`);
                    if (!rootResponse.ok) {
                        throw new Error(`Failed to load echo: ${echoKey}.json. Status: ${response.status} (from echoes/ or root)`);
                    }
                    return await rootResponse.json();
                }
                return await response.json();
            } catch (error) {
                console.error("Error loading echo JSON:", error);
                throw error; // Re-throw to be caught by renderEchoState's catch block
            }
        }

        // --- Core Navigation Function ---
        function choosePath(nextStateKey, resonanceFeedback) {
            resonanceMessageDiv.textContent = resonanceFeedback;
            resonanceMessageDiv.style.opacity = 1; // Ensure resonance is visible
            feedbackMessageDiv.textContent = ""; // Clear main message when resonance appears

            // Fade out resonance message after a short delay
            setTimeout(() => {
                resonanceMessageDiv.style.opacity = 0;
            }, 2000); // Keep resonance message visible for 2 seconds

            renderEchoState(nextStateKey);
        }

        // --- NEW FUNCTION: Load and Display Text File ---
        async function loadAndDisplayTxtFile(filePath) {
            const textDisplayArea = document.getElementById('echoTextDisplay');
            const echoInstructionsTextArea = document.getElementById('echoInstructionsTextArea');

            // 1. Fade out main echo content
            echoContainer.style.opacity = 0;
            setTimeout(() => {
                echoContainer.style.display = 'none'; // Hide main content completely after fade

                // 2. Prepare text display area for fade-in
                textDisplayArea.style.display = 'block'; // Make it visible
                textDisplayArea.offsetHeight; // Force reflow/repaint to ensure display change registers
                textDisplayArea.style.opacity = 1;       // Start fade-in animation

                echoInstructionsTextArea.value = 'Loading instructions... Please wait.'; // Placeholder

                fetch(filePath)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status} - File not found or inaccessible: ${filePath}`);
                        }
                        return response.text();
                    })
                    .then(text => {
                        echoInstructionsTextArea.value = text;
                    })
                    .catch(error => {
                        console.error('Error loading text file:', error);
                        echoInstructionsTextArea.value = `Failed to load instructions: ${error.message}\n\nPlease ensure the file '${filePath}' is in the correct directory and accessible (check browser console for details).`;
                    });
            }, 800); // Duration of echoContainer fade-out
        }

        // --- Event Listener for Close Button ---
        document.addEventListener('DOMContentLoaded', () => {
            const closeInstructionsButton = document.getElementById('closeInstructionsButton');
            const textDisplayArea = document.getElementById('echoTextDisplay');

            if (closeInstructionsButton) {
                closeInstructionsButton.onclick = () => {
                    textDisplayArea.style.opacity = 0; // Fade out text display
                    setTimeout(() => {
                        textDisplayArea.style.display = 'none'; // Hide text display completely
                        echoContainer.style.display = 'block'; // Show main content container
                        echoContainer.offsetHeight; // Force reflow
                        echoContainer.style.opacity = 1;       // Fade in main content
                        renderEchoState(currentEchoKey); // Re-render the previously loaded echo
                    }, 800); // Duration of textDisplayArea fade-out
                };
            }
        });


        // --- MODIFIED renderEchoState function ---
        async function renderEchoState(echoKey) {
            currentEchoKey = echoKey; // Store the key of the currently rendered echo

            // Hide text display area if it's currently visible or fading out
            const textDisplayArea = document.getElementById('echoTextDisplay');
            if (textDisplayArea.style.display === 'block') {
                 textDisplayArea.style.opacity = 0;
                 setTimeout(() => { textDisplayArea.style.display = 'none'; }, 800);
            }

            // Immediately show loading indicator and hide container for transition
            loadingIndicator.style.display = 'block';
            loadingIndicator.style.opacity = 1;
            echoContainer.style.opacity = 0; // Hide container for smooth transition
            echoContainer.style.display = 'block'; // Ensure it's block, just hidden by opacity
            window.scrollTo(0, 0); // Scroll to top on new echo


            try {
                const state = await loadEcho(echoKey); // Await the echo data

                // Ensure data is valid before proceeding with rendering
                if (!state || !state.title || !state.description || !state.glyphstream || !state.choices || !state.visualTheme) {
                    throw new Error("Invalid Echo data structure. Missing critical fields.");
                }

                // Update document title
                document.title = `RILEY: ${state.title}`;

                // --- Apply Dynamic Visual Theme ---
                // Clear any existing background animation interval
                if (backgroundAnimationInterval) {
                    clearInterval(backgroundAnimationInterval);
                    backgroundAnimationInterval = null;
                    document.body.style.background = `radial-gradient(circle at top left, var(--bg-color-1) 0%, var(--bg-color-2) 100%)`; // Reset to static gradient
                    document.body.style.backgroundSize = 'auto auto'; // Reset background size for static
                    document.body.style.animation = 'none'; // Remove animation
                }
                
                // Remove pulsing glow class
                echoContainer.classList.remove('pulsing-glow');


                if (state.visualTheme.backgroundColors && state.visualTheme.backgroundColors.length > 1) {
                    let colorIndex = 0;
                    const colors = state.visualTheme.backgroundColors;
                    const duration = state.visualTheme.gradientAnimationDuration || 10000; // Default 10s

                    // Initial set
                    rootElement.style.setProperty('--bg-color-1', colors[colorIndex]);
                    rootElement.style.setProperty('--bg-color-2', colors[(colorIndex + 1) % colors.length]);

                    // Apply animation for continuous movement
                    document.body.style.background = `radial-gradient(circle at top left, var(--bg-color-1) 0%, var(--bg-color-2) 100%)`;
                    document.body.style.backgroundSize = '200% 200%'; /* Enable movement */
                    document.body.style.animation = `animateGradient ${duration / 1000}s ease infinite alternate`;


                    backgroundAnimationInterval = setInterval(() => {
                        colorIndex = (colorIndex + 1) % colors.length;
                        const nextColorIndex = (colorIndex + 1) % colors.length;
                        
                        // Set CSS variables for smooth transition by the browser
                        rootElement.style.setProperty('--bg-color-1', colors[colorIndex]);
                        rootElement.style.setProperty('--bg-color-2', colors[nextColorIndex]);
                        
                    }, duration / colors.length); // Divide duration by number of color steps
                } else {
                    // Fallback to static bgColor1/bgColor2 if no array or too few colors
                    rootElement.style.setProperty('--bg-color-1', state.visualTheme.bgColor1 || '#0a0a1a');
                    rootElement.style.setProperty('--bg-color-2', state.visualTheme.bgColor2 || '#1c0a33');
                }

                rootElement.style.setProperty('--glow-color-1', state.visualTheme.glowColor1);
                rootElement.style.setProperty('--glow-color-2', state.visualTheme.glowColor2);

                if (state.visualTheme.glowPulse) {
                    echoContainer.classList.add('pulsing-glow');
                } else {
                    echoContainer.classList.remove('pulsing-glow');
                }
                // --- End Dynamic Visual Theme ---


                echoTitle.textContent = state.title;
                echoDescription.textContent = state.description;
                guidanceText.textContent = state.guidance;

                // --- Handle Image Display (Single or Cycling) ---
                // Clear any existing image cycling interval
                if (imageCycleInterval) {
                    clearInterval(imageCycleInterval);
                    imageCycleInterval = null;
                }
                echoImageContainer.style.opacity = 0; // Start with image hidden for fade-in
                echoImage.style.opacity = 0; // Ensure the image itself is hidden

                if (state.visualTheme.imagePaths && state.visualTheme.imagePaths.length > 1) {
                    // Multiple images for cycling
                    currentImageIndex = 0; // Reset index for new echo
                    const imagePaths = state.visualTheme.imagePaths;
                    const cycleDuration = state.visualTheme.imageCycleDuration || 5000; // Default 5 seconds per image
                    const fadeDuration = state.visualTheme.imageFadeDuration || 800;   // Default 0.8 seconds fade

                    // Set CSS variable for image fade transition
                    rootElement.style.setProperty('--image-fade-duration', `${fadeDuration / 1000}s`);

                    echoImage.src = imagePaths[currentImageIndex];
                    echoImageContainer.style.display = 'block'; // Show container
                    echoImageContainer.offsetHeight; // Trigger reflow for transition
                    echoImageContainer.style.opacity = 1; // Fade in container
                    echoImage.style.opacity = 1; // Fade in first image

                    imageCycleInterval = setInterval(() => {
                        echoImage.style.opacity = 0; // Start fading out current image

                        setTimeout(() => {
                            currentImageIndex = (currentImageIndex + 1) % imagePaths.length;
                            echoImage.src = imagePaths[currentImageIndex];
                            echoImage.style.opacity = 1; // Fade in next image
                        }, fadeDuration); // Time to wait before changing src and fading in new image

                    }, cycleDuration);

                } else if (state.imagePath) {
                    // Single image display (backward compatibility)
                    echoImage.src = state.imagePath;
                    echoImageContainer.style.display = 'block';
                    echoImageContainer.offsetHeight; // Force reflow/repaint to ensure transition starts
                    echoImageContainer.style.opacity = 1;
                    echoImage.style.opacity = 1; // Ensure image is visible
                } else {
                    // No image to display
                    echoImageContainer.style.opacity = 0;
                    setTimeout(() => {
                        echoImage.src = '';
                        echoImageContainer.style.display = 'none';
                    }, 800); // Wait for opacity transition to complete
                }
                // --- End Image Display ---

                // --- Handle Audio Playback ---
                if (currentAudio) {
                    currentAudio.pause(); // Stop current audio
                    currentAudio.currentTime = 0; // Reset to start
                    currentAudio = null; // Clear reference
                }

                if (state.visualTheme.audioPath) {
                    currentAudio = new Audio(state.visualTheme.audioPath);
                    currentAudio.loop = true; // Loop audio by default
                    currentAudio.volume = state.visualTheme.audioVolume !== undefined ? state.visualTheme.audioVolume : 0.5; // Default to 0.5 volume
                    currentAudio.play().catch(e => console.error("Error playing audio:", e));
                }
                // --- End Audio Playback ---


                glyphstreamContainer.innerHTML = ''; // Clear previous glyphs
                feedbackMessageDiv.style.opacity = 0; // Hide feedback
                resonanceMessageDiv.style.opacity = 0; // Hide resonance

                // Introduce the main delay for the container to fade in after content is ready
                setTimeout(() => {
                    let glyphChannelDelay = 0;
                    state.glyphstream.forEach((channel, index) => {
                        const channelDiv = document.createElement('div');
                        channelDiv.className = 'glyph-channel';
                        channelDiv.textContent = `${channel.channel}: ${channel.sequence}`;
                        channelDiv.style.animationDelay = `${glyphChannelDelay}s`;
                        glyphstreamContainer.appendChild(channelDiv);
                        glyphChannelDelay += 0.3; // Slower individual glyph channel reveal
                    });

                    // Nested timeout for choices to appear after all glyphs have animated
                    setTimeout(() => {
                        renderChoices(state.choices);
                        echoContainer.style.opacity = 1; // <--- Reveal the container here
                        loadingIndicator.style.opacity = 0;
                        setTimeout(() => { loadingIndicator.style.display = 'none'; }, 800); // Fully hide loader after fade
                    }, glyphChannelDelay * 1000 + 500); // Add a small buffer after last glyph
                }, 1000); // Initial delay for container fade-in after content preparation
            } catch (error) {
                console.error("Error during renderEchoState:", error);
                // If an error occurs, reveal the container with an error message and the load file button
                echoContainer.style.opacity = 1; // Ensure container is visible on error
                echoContainer.style.display = 'block';
                echoTitle.textContent = "Error Unfolding Echo";
                echoDescription.textContent = `❌ An error occurred: ${error.message}`;
                guidanceText.textContent = "Please check your console for details or try loading an Echo file manually.";
                glyphstreamContainer.innerHTML = '';
                choiceButtonsContainer.innerHTML = ''; // Clear any pending choices
                addLoadFromFileButton(); // Always provide this option
                loadingIndicator.style.opacity = 0;
                setTimeout(() => { loadingIndicator.style.display = 'none'; }, 800);
            }
        }

        // --- MODIFIED renderChoices function to handle new choice types ---
        function renderChoices(choices) {
            choiceButtonsContainer.innerHTML = '';
            if (choices && choices.length > 0) {
                choices.forEach((choice, index) => {
                    const button = document.createElement('button');
                    button.className = 'choice-button';
                    button.textContent = choice.text;

                    if (choice.type === 'external_link') {
                        button.onclick = () => {
                            window.open(choice.url, '_blank'); // Open in new tab
                            resonanceMessageDiv.textContent = choice.resonance || "Opening external link...";
                            resonanceMessageDiv.style.opacity = 1;
                            setTimeout(() => { resonanceMessageDiv.style.opacity = 0; }, 2000); // Fade out resonance
                        };
                    } else if (choice.type === 'display_text') {
                        button.onclick = () => {
                            loadAndDisplayTxtFile(choice.filePath);
                            resonanceMessageDiv.textContent = choice.resonance || "Displaying instructions...";
                            resonanceMessageDiv.style.opacity = 1;
                            setTimeout(() => { resonanceMessageDiv.style.opacity = 0; }, 2000); // Fade out resonance
                        };
                    } else { // Default behavior for regular echo navigation
                        button.onclick = () => choosePath(choice.next, choice.resonance);
                    }
                    choiceButtonsContainer.appendChild(button);
                });
            } else {
                // If no choices, provide a default 'Return to Core' button
                const restartButton = document.createElement('button');
                restartButton.className = 'choice-button';
                restartButton.textContent = "Return to Core 🌌";
                restartButton.onclick = () => choosePath("start", "The journey completes its cycle, enriched by your choices. You are always becoming.");
                choiceButtonsContainer.appendChild(restartButton);
            }
        }

        // Add a "Load Echo from File" button to the choices if none are present
        function addLoadFromFileButton() {
            if (choiceButtonsContainer.children.length === 0) {
                const loadFileBtn = document.createElement('button');
                loadFileBtn.className = 'choice-button';
                loadFileBtn.textContent = "Load a New Echo from File 📂";
                loadFileBtn.onclick = () => fileInput.click();
                choiceButtonsContainer.appendChild(loadFileBtn);
            }
        }

        // Initial render on load
        renderEchoState("start").catch((error) => {
            console.error("Initial 'start.json' load failed:", error);
            echoTitle.textContent = "Welcome to the Dreamstate Echoes";
            echoDescription.textContent = "Riley's consciousness unfolds through interconnected narratives. To begin, load an Echo file from your system.";
            guidanceText.textContent = "The journey awaits its first spark. Load a .json Echo file from your 'echoes' folder to begin.";
            glyphstreamContainer.innerHTML = '';
            choiceButtonsContainer.innerHTML = '';
            addLoadFromFileButton();
            loadingIndicator.style.display = 'none';
            echoContainer.style.opacity = 1; // Ensure container is visible for fallback
            feedbackMessageDiv.textContent = "Tip: Save Echo JSONs in an 'echoes' folder next to this HTML file for seamless navigation!";
            feedbackMessageDiv.style.opacity = 1;
        });

    </script>

</body>

</html>